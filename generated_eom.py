"""
Trebuchet-Level-4: Generated Equations of Motion
=================================================
AUTO-GENERATED FILE - DO NOT EDIT MANUALLY
Generated by derive_physics.py

This module contains the mass matrix M and force vector F
such that M @ q_ddot = F, where q = [theta, beta, gamma, phi]
"""

import numpy as np
from numpy import sin, cos, sqrt, pi


def compute_M(th, bt, gm, ph, dth, dbt, dgm, dph,
            L_root, L_tip, L_hanger, L_sling, H,
            m_root, m_tip, M_cw, m_proj,
            I_root, I_tip, k_stiff, c_damp, g,
            R_cam, dR_cam, ddR_cam, psi, dpsi, ddpsi):
    """Compute compute_M matrix (4x4)."""
    result = np.zeros((4, 4))
    result[0, 0] = I_root + I_tip + (1/2)*M_cw*(2*R_cam**2*np.sin(psi + th)**2 + 2*R_cam**2*np.cos(psi + th)**2) + (1/2)*m_proj*((L_root*np.sin(th) + L_tip*np.sin(bt + th))*(2*L_root*np.sin(th) + 2*L_tip*np.sin(bt + th)) + (L_root*np.cos(th) + L_tip*np.cos(bt + th))*(2*L_root*np.cos(th) + 2*L_tip*np.cos(bt + th))) + (1/2)*m_tip*((L_root*np.sin(th) + (1/2)*L_tip*np.sin(bt + th))*(2*L_root*np.sin(th) + L_tip*np.sin(bt + th)) + (L_root*np.cos(th) + (1/2)*L_tip*np.cos(bt + th))*(2*L_root*np.cos(th) + L_tip*np.cos(bt + th)))
    result[0, 1] = I_tip + (1/2)*m_proj*(L_tip*(2*L_root*np.sin(th) + 2*L_tip*np.sin(bt + th))*np.sin(bt + th) + L_tip*(2*L_root*np.cos(th) + 2*L_tip*np.cos(bt + th))*np.cos(bt + th)) + (1/2)*m_tip*((1/2)*L_tip*(2*L_root*np.sin(th) + L_tip*np.sin(bt + th))*np.sin(bt + th) + (1/2)*L_tip*(2*L_root*np.cos(th) + L_tip*np.cos(bt + th))*np.cos(bt + th))
    result[0, 2] = (1/2)*M_cw*(-2*L_hanger*R_cam*np.sin(gm)*np.sin(psi + th) - 2*L_hanger*R_cam*np.cos(gm)*np.cos(psi + th))
    result[0, 3] = (1/2)*m_proj*(L_sling*(2*L_root*np.sin(th) + 2*L_tip*np.sin(bt + th))*np.sin(ph) + L_sling*(2*L_root*np.cos(th) + 2*L_tip*np.cos(bt + th))*np.cos(ph))
    result[1, 0] = I_tip + (1/2)*m_proj*(2*L_tip*(L_root*np.sin(th) + L_tip*np.sin(bt + th))*np.sin(bt + th) + 2*L_tip*(L_root*np.cos(th) + L_tip*np.cos(bt + th))*np.cos(bt + th)) + (1/2)*m_tip*(L_tip*(L_root*np.sin(th) + (1/2)*L_tip*np.sin(bt + th))*np.sin(bt + th) + L_tip*(L_root*np.cos(th) + (1/2)*L_tip*np.cos(bt + th))*np.cos(bt + th))
    result[1, 1] = I_tip + (1/2)*m_proj*(2*L_tip**2*np.sin(bt + th)**2 + 2*L_tip**2*np.cos(bt + th)**2) + (1/2)*m_tip*((1/2)*L_tip**2*np.sin(bt + th)**2 + (1/2)*L_tip**2*np.cos(bt + th)**2)
    result[1, 3] = (1/2)*m_proj*(2*L_sling*L_tip*np.sin(ph)*np.sin(bt + th) + 2*L_sling*L_tip*np.cos(ph)*np.cos(bt + th))
    result[2, 0] = (1/2)*M_cw*(-2*L_hanger*R_cam*np.sin(gm)*np.sin(psi + th) - 2*L_hanger*R_cam*np.cos(gm)*np.cos(psi + th))
    result[2, 2] = (1/2)*M_cw*(2*L_hanger**2*np.sin(gm)**2 + 2*L_hanger**2*np.cos(gm)**2)
    result[3, 0] = (1/2)*m_proj*(2*L_sling*(L_root*np.sin(th) + L_tip*np.sin(bt + th))*np.sin(ph) + 2*L_sling*(L_root*np.cos(th) + L_tip*np.cos(bt + th))*np.cos(ph))
    result[3, 1] = (1/2)*m_proj*(2*L_sling*L_tip*np.sin(ph)*np.sin(bt + th) + 2*L_sling*L_tip*np.cos(ph)*np.cos(bt + th))
    result[3, 3] = (1/2)*m_proj*(2*L_sling**2*np.sin(ph)**2 + 2*L_sling**2*np.cos(ph)**2)
    return result


def compute_F(th, bt, gm, ph, dth, dbt, dgm, dph,
            L_root, L_tip, L_hanger, L_sling, H,
            m_root, m_tip, M_cw, m_proj,
            I_root, I_tip, k_stiff, c_damp, g,
            R_cam, dR_cam, ddR_cam, psi, dpsi, ddpsi):
    """Compute compute_F vector (4x1)."""
    result = np.zeros(4)
    result[0] = -1/2*L_root*g*m_root*np.sin(th) + M_cw*R_cam*g*np.sin(psi + th) + (1/2)*M_cw*(-2*R_cam*dth*(L_hanger*dgm*np.sin(gm) - R_cam*dth*np.sin(psi + th))*np.cos(psi + th) + 2*R_cam*dth*(L_hanger*dgm*np.cos(gm) - R_cam*dth*np.cos(psi + th))*np.sin(psi + th)) - 1/2*M_cw*(-2*R_cam*dth*(L_hanger*dgm*np.sin(gm) - R_cam*dth*np.sin(psi + th))*np.cos(psi + th) + 2*R_cam*dth*(L_hanger*dgm*np.cos(gm) - R_cam*dth*np.cos(psi + th))*np.sin(psi + th) - 2*R_cam*(-L_hanger*dgm**2*np.sin(gm) + R_cam*dth**2*np.sin(psi + th))*np.cos(psi + th) - 2*R_cam*(L_hanger*dgm**2*np.cos(gm) - R_cam*dth**2*np.cos(psi + th))*np.sin(psi + th)) - g*m_proj*(L_root*np.sin(th) + L_tip*np.sin(bt + th)) - g*m_tip*(L_root*np.sin(th) + (1/2)*L_tip*np.sin(bt + th)) + (1/2)*m_proj*((-2*L_root*dth*np.sin(th) - 2*L_tip*(dbt + dth)*np.sin(bt + th))*(L_root*dth*np.cos(th) + L_sling*dph*np.cos(ph) + L_tip*(dbt + dth)*np.cos(bt + th)) + (2*L_root*dth*np.cos(th) + 2*L_tip*(dbt + dth)*np.cos(bt + th))*(L_root*dth*np.sin(th) + L_sling*dph*np.sin(ph) + L_tip*(dbt + dth)*np.sin(bt + th))) - 1/2*m_proj*((2*L_root*np.sin(th) + 2*L_tip*np.sin(bt + th))*(L_root*dth**2*np.cos(th) + L_sling*dph**2*np.cos(ph) + L_tip*(dbt + dth)**2*np.cos(bt + th)) + (2*L_root*np.cos(th) + 2*L_tip*np.cos(bt + th))*(-L_root*dth**2*np.sin(th) - L_sling*dph**2*np.sin(ph) - L_tip*(dbt + dth)**2*np.sin(bt + th)) + (-2*L_root*dth*np.sin(th) - 2*L_tip*(dbt + dth)*np.sin(bt + th))*(L_root*dth*np.cos(th) + L_sling*dph*np.cos(ph) + L_tip*(dbt + dth)*np.cos(bt + th)) + (2*L_root*dth*np.cos(th) + 2*L_tip*(dbt + dth)*np.cos(bt + th))*(L_root*dth*np.sin(th) + L_sling*dph*np.sin(ph) + L_tip*(dbt + dth)*np.sin(bt + th))) + (1/2)*m_tip*((-2*L_root*dth*np.sin(th) - L_tip*(dbt + dth)*np.sin(bt + th))*(L_root*dth*np.cos(th) + (1/2)*L_tip*(dbt + dth)*np.cos(bt + th)) + (L_root*dth*np.sin(th) + (1/2)*L_tip*(dbt + dth)*np.sin(bt + th))*(2*L_root*dth*np.cos(th) + L_tip*(dbt + dth)*np.cos(bt + th))) - 1/2*m_tip*((2*L_root*np.sin(th) + L_tip*np.sin(bt + th))*(L_root*dth**2*np.cos(th) + (1/2)*L_tip*(dbt + dth)**2*np.cos(bt + th)) + (2*L_root*np.cos(th) + L_tip*np.cos(bt + th))*(-L_root*dth**2*np.sin(th) - 1/2*L_tip*(dbt + dth)**2*np.sin(bt + th)) + (-2*L_root*dth*np.sin(th) - L_tip*(dbt + dth)*np.sin(bt + th))*(L_root*dth*np.cos(th) + (1/2)*L_tip*(dbt + dth)*np.cos(bt + th)) + (L_root*dth*np.sin(th) + (1/2)*L_tip*(dbt + dth)*np.sin(bt + th))*(2*L_root*dth*np.cos(th) + L_tip*(dbt + dth)*np.cos(bt + th)))
    result[1] = -L_tip*g*m_proj*np.sin(bt + th) - 1/2*L_tip*g*m_tip*np.sin(bt + th) - bt*k_stiff - c_damp*dbt + (1/2)*m_proj*(2*L_tip*(dbt + dth)*(L_root*dth*np.sin(th) + L_sling*dph*np.sin(ph) + L_tip*(dbt + dth)*np.sin(bt + th))*np.cos(bt + th) - 2*L_tip*(dbt + dth)*(L_root*dth*np.cos(th) + L_sling*dph*np.cos(ph) + L_tip*(dbt + dth)*np.cos(bt + th))*np.sin(bt + th)) - 1/2*m_proj*(2*L_tip*(dbt + dth)*(L_root*dth*np.sin(th) + L_sling*dph*np.sin(ph) + L_tip*(dbt + dth)*np.sin(bt + th))*np.cos(bt + th) - 2*L_tip*(dbt + dth)*(L_root*dth*np.cos(th) + L_sling*dph*np.cos(ph) + L_tip*(dbt + dth)*np.cos(bt + th))*np.sin(bt + th) + 2*L_tip*(-L_root*dth**2*np.sin(th) - L_sling*dph**2*np.sin(ph) - L_tip*(dbt + dth)**2*np.sin(bt + th))*np.cos(bt + th) + 2*L_tip*(L_root*dth**2*np.cos(th) + L_sling*dph**2*np.cos(ph) + L_tip*(dbt + dth)**2*np.cos(bt + th))*np.sin(bt + th)) + (1/2)*m_tip*(L_tip*(dbt + dth)*(L_root*dth*np.sin(th) + (1/2)*L_tip*(dbt + dth)*np.sin(bt + th))*np.cos(bt + th) - L_tip*(dbt + dth)*(L_root*dth*np.cos(th) + (1/2)*L_tip*(dbt + dth)*np.cos(bt + th))*np.sin(bt + th)) - 1/2*m_tip*(L_tip*(dbt + dth)*(L_root*dth*np.sin(th) + (1/2)*L_tip*(dbt + dth)*np.sin(bt + th))*np.cos(bt + th) - L_tip*(dbt + dth)*(L_root*dth*np.cos(th) + (1/2)*L_tip*(dbt + dth)*np.cos(bt + th))*np.sin(bt + th) + L_tip*(-L_root*dth**2*np.sin(th) - 1/2*L_tip*(dbt + dth)**2*np.sin(bt + th))*np.cos(bt + th) + L_tip*(L_root*dth**2*np.cos(th) + (1/2)*L_tip*(dbt + dth)**2*np.cos(bt + th))*np.sin(bt + th))
    result[2] = -L_hanger*M_cw*g*np.sin(gm) + (1/2)*M_cw*(2*L_hanger*dgm*(L_hanger*dgm*np.sin(gm) - R_cam*dth*np.sin(psi + th))*np.cos(gm) - 2*L_hanger*dgm*(L_hanger*dgm*np.cos(gm) - R_cam*dth*np.cos(psi + th))*np.sin(gm)) - 1/2*M_cw*(2*L_hanger*dgm*(L_hanger*dgm*np.sin(gm) - R_cam*dth*np.sin(psi + th))*np.cos(gm) - 2*L_hanger*dgm*(L_hanger*dgm*np.cos(gm) - R_cam*dth*np.cos(psi + th))*np.sin(gm) + 2*L_hanger*(-L_hanger*dgm**2*np.sin(gm) + R_cam*dth**2*np.sin(psi + th))*np.cos(gm) + 2*L_hanger*(L_hanger*dgm**2*np.cos(gm) - R_cam*dth**2*np.cos(psi + th))*np.sin(gm))
    result[3] = -L_sling*g*m_proj*np.sin(ph) + (1/2)*m_proj*(2*L_sling*dph*(L_root*dth*np.sin(th) + L_sling*dph*np.sin(ph) + L_tip*(dbt + dth)*np.sin(bt + th))*np.cos(ph) - 2*L_sling*dph*(L_root*dth*np.cos(th) + L_sling*dph*np.cos(ph) + L_tip*(dbt + dth)*np.cos(bt + th))*np.sin(ph)) - 1/2*m_proj*(2*L_sling*dph*(L_root*dth*np.sin(th) + L_sling*dph*np.sin(ph) + L_tip*(dbt + dth)*np.sin(bt + th))*np.cos(ph) - 2*L_sling*dph*(L_root*dth*np.cos(th) + L_sling*dph*np.cos(ph) + L_tip*(dbt + dth)*np.cos(bt + th))*np.sin(ph) + 2*L_sling*(-L_root*dth**2*np.sin(th) - L_sling*dph**2*np.sin(ph) - L_tip*(dbt + dth)**2*np.sin(bt + th))*np.cos(ph) + 2*L_sling*(L_root*dth**2*np.cos(th) + L_sling*dph**2*np.cos(ph) + L_tip*(dbt + dth)**2*np.cos(bt + th))*np.sin(ph))
    return result


def compute_p_pivot(th, bt, gm, ph, L_root, L_tip, L_hanger, L_sling, H, R_cam, psi):
    """Compute compute_p_pivot position (x, y)."""
    x = 0
    y = H
    return np.array([x, y])


def compute_p_joint(th, bt, gm, ph, L_root, L_tip, L_hanger, L_sling, H, R_cam, psi):
    """Compute compute_p_joint position (x, y)."""
    x = L_root*np.sin(th)
    y = H - L_root*np.cos(th)
    return np.array([x, y])


def compute_p_tip(th, bt, gm, ph, L_root, L_tip, L_hanger, L_sling, H, R_cam, psi):
    """Compute compute_p_tip position (x, y)."""
    x = L_root*np.sin(th) + L_tip*np.sin(bt + th)
    y = H - L_root*np.cos(th) - L_tip*np.cos(bt + th)
    return np.array([x, y])


def compute_p_proj(th, bt, gm, ph, L_root, L_tip, L_hanger, L_sling, H, R_cam, psi):
    """Compute compute_p_proj position (x, y)."""
    x = L_root*np.sin(th) + L_sling*np.sin(ph) + L_tip*np.sin(bt + th)
    y = H - L_root*np.cos(th) - L_sling*np.cos(ph) - L_tip*np.cos(bt + th)
    return np.array([x, y])


def compute_p_cam_pin(th, bt, gm, ph, L_root, L_tip, L_hanger, L_sling, H, R_cam, psi):
    """Compute compute_p_cam_pin position (x, y)."""
    x = -R_cam*np.sin(psi + th)
    y = H + R_cam*np.cos(psi + th)
    return np.array([x, y])


def compute_p_cw(th, bt, gm, ph, L_root, L_tip, L_hanger, L_sling, H, R_cam, psi):
    """Compute compute_p_cw position (x, y)."""
    x = L_hanger*np.sin(gm) - R_cam*np.sin(psi + th)
    y = H - L_hanger*np.cos(gm) + R_cam*np.cos(psi + th)
    return np.array([x, y])


def compute_v_proj(th, bt, gm, ph, dth, dbt, dgm, dph,
                   L_root, L_tip, L_sling, R_cam, dR_cam, psi, dpsi):
    """Compute projectile velocity (vx, vy)."""
    vx = L_root*dth*np.cos(th) + L_sling*dph*np.cos(ph) + L_tip*(dbt + dth)*np.cos(bt + th)
    vy = L_root*dth*np.sin(th) + L_sling*dph*np.sin(ph) + L_tip*(dbt + dth)*np.sin(bt + th)
    return np.array([vx, vy])


def compute_v_cw(th, bt, gm, ph, dth, dbt, dgm, dph,
                 L_root, L_hanger, R_cam, dR_cam, psi, dpsi):
    """Compute counterweight velocity (vx, vy)."""
    vx = L_hanger*dgm*np.cos(gm) - R_cam*dth*np.cos(psi + th)
    vy = L_hanger*dgm*np.sin(gm) - R_cam*dth*np.sin(psi + th)
    return np.array([vx, vy])



def compute_accelerations(state, params):
    """
    Compute accelerations given state and parameters.

    Parameters
    ----------
    state : array_like
        State vector [theta, beta, gamma, phi, d_theta, d_beta, d_gamma, d_phi]
    params : dict
        Dictionary with keys: L_root, L_tip, L_hanger, L_sling, H,
                              m_root, m_tip, M_cw, m_proj, I_root, I_tip,
                              k_stiff, c_damp, g, R_cam, dR_cam, ddR_cam,
                              psi, dpsi, ddpsi

    Returns
    -------
    accelerations : ndarray
        Array [dd_theta, dd_beta, dd_gamma, dd_phi]
    """
    th, bt, gm, ph, dth, dbt, dgm, dph = state

    # Extract parameters
    L_root = params['L_root']
    L_tip = params['L_tip']
    L_hanger = params['L_hanger']
    L_sling = params['L_sling']
    H = params['H']
    m_root = params['m_root']
    m_tip = params['m_tip']
    M_cw = params['M_cw']
    m_proj = params['m_proj']
    I_root = params['I_root']
    I_tip = params['I_tip']
    k_stiff = params['k_stiff']
    c_damp = params['c_damp']
    g = params['g']
    R_cam = params['R_cam']
    dR_cam = params['dR_cam']
    ddR_cam = params['ddR_cam']
    psi = params['psi']
    dpsi = params['dpsi']
    ddpsi = params['ddpsi']

    # Compute mass matrix and force vector
    M = compute_M(th, bt, gm, ph, dth, dbt, dgm, dph,
                  L_root, L_tip, L_hanger, L_sling, H,
                  m_root, m_tip, M_cw, m_proj,
                  I_root, I_tip, k_stiff, c_damp, g,
                  R_cam, dR_cam, ddR_cam, psi, dpsi, ddpsi)

    F = compute_F(th, bt, gm, ph, dth, dbt, dgm, dph,
                  L_root, L_tip, L_hanger, L_sling, H,
                  m_root, m_tip, M_cw, m_proj,
                  I_root, I_tip, k_stiff, c_damp, g,
                  R_cam, dR_cam, ddR_cam, psi, dpsi, ddpsi)

    # Solve M @ ddq = F for accelerations
    try:
        accelerations = np.linalg.solve(M, F)
    except np.linalg.LinAlgError:
        # Singular matrix - return zeros
        accelerations = np.zeros(4)

    return accelerations
